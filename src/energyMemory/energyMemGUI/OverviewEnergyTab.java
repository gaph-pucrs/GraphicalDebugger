/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package energyMemory.energyMemGUI;

import energyMemory.energyMemGUI.ControlPanel.TilePlotType;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.ArrayList;
import energyMemory.monitoredData.EnergyInfo;

/**
 *
 * @author ruaro
 */
public class OverviewEnergyTab extends javax.swing.JPanel {
    
        private ControlPanel controlPanel;
        private ArrayList<OverviewTilePanel> energyTilePanels;
        private EnergyInfo energyInfo;
    /**
     * Creates new form EnergyOverview
     */
    public OverviewEnergyTab(Dimension parentDimm, ControlPanel controlPanel, EnergyInfo energyInfo) {
        this.energyInfo = energyInfo;
        this.controlPanel = controlPanel;
        
        initComponents();
        
        this.setPreferredSize(parentDimm);
        resetTileGrid();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setLayout(new java.awt.GridBagLayout());
    }// </editor-fold>//GEN-END:initComponents

        //Recompute the alread read values
    //The goal of this function is to fake the address of the controlPanel, and artifically (not by reading files) redo the calculus
    public void refreshPlots(){
        
        
        int ori_num_windows = controlPanel.getNum_windows();
        
        for (OverviewTilePanel tilePanel : energyTilePanels) {
            tilePanel.resetValueList();
        }
        
        if (controlPanel.isNormalize_window()){
            controlPanel.setMaxValueEnergyTile_nJ(0);
        }
        
        controlPanel.resetWindow();
        
        while(controlPanel.getNum_windows() < ori_num_windows){
            updateTiles();
            controlPanel.advanceWindow();
        }
        
    }
    
    //Update to each window
    public void updateTiles(){
        
        
        float tile_energy;
        boolean window_change = false;
        
        for (OverviewTilePanel tilePanel : energyTilePanels) {
            
            int addr = tilePanel.getAddr();
            //System.out.println(tilePanel.getAddr());
            //if (addr == 0){
                //System.out.println("*******************");
                tile_energy = energyInfo.computeTotalTileWindowEnergy(addr, controlPanel.getMin_window_time(), controlPanel.getMax_window_time());
                
                /*System.out.println("Min: "+controlPanel.getMin_window_time());
                System.out.println("Max: "+controlPanel.getMax_window_time());
                System.out.println("Window Energy: "+tile_energy);
                System.out.println("total Energy: "+energyInfo.computeTotalTileEnergy(addr));
                System.out.println("------------------");*/
                
                if (tile_energy > controlPanel.getMaxValueEnergyTile_nJ() && controlPanel.isNormalize_window()){
                    controlPanel.setMaxValueEnergyTile_nJ(tile_energy);
                    window_change = true;
                }
                
                tilePanel.addWindowEnergyValue(tile_energy, energyInfo.computeTotalTileEnergy(tilePanel.getAddr()));
            //}
        }
        
        //Maybe this can be removed - removed for while, case the bars dont update accordly is necessary to redo this
        if (window_change){
            for (OverviewTilePanel tilePanel : energyTilePanels) {
                tilePanel.repaint();
            }
        }
        //System.out.println("Total Energy: "+energyInfo.computeTotalEnergyWindow(controlPanel.getMin_window_time(), controlPanel.getMax_window_time()));
        
    }
    
    public void resetTileGrid() {
        
        GridBagLayout gridBagLayout = new GridBagLayout();
        GridBagConstraints cons = new GridBagConstraints();
        
        int XDIM = controlPanel.getXDIM();
        int YDIM = controlPanel.getYDIM();
        
        this.removeAll();
        this.setBackground(Color.white);
        this.setLayout(gridBagLayout);
        
        OverviewTilePanel energyTilePanel;
        this.energyTilePanels = new ArrayList<>();
        
        //System.out.println(this.getPreferredSize().getSize().height);
        //System.out.println(this.getPreferredSize().getSize().width/XDIM);
        cons.fill = GridBagConstraints.BOTH;
        cons.gridy = 0;
        //for (int y = 0; y < mpsocConfig.getY_dimension(); y++) {
        for (int y = 0; y < YDIM; y++) {
            cons.gridx = 0;
            //for (int x = 0; x < mpsocConfig.getX_dimension(); x++) {
            for (int x = 0; x < XDIM; x++) {
                cons.gridx++;
                
                energyTilePanel = new OverviewTilePanel(controlPanel, energyInfo, (x << 8 | y), TilePlotType.PLOT_ENERGY);
                
                energyTilePanels.add(energyTilePanel);
                
                this.add(energyTilePanel, cons);
            }
            cons.gridy++;
        }
        
        this.revalidate();
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
